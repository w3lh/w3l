/*
    w3l: a PvPGN loader for Warcraft 3 1.22+
    Copyright (C) 2008 Rupan, Keres, Phatdeeva

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "w3lh.h"
//#define DO_HASH_OFFSET 0x85B74C
//#define DO_HASH_OFFSET 0x85BE1E

typedef struct _sig {
	int length;	/* length of signature data */
	/* signature data. This is an array of size 'length' * 2
	   with each entry if the format of mask,val where mask
	   is logical anded with the current byte being searched and
	   then compared with val. This way you can ignore certain bytes
	   in a signature */
	char *data;
	/* delta is added to the offset of where the signature was found */
	int delta;
	char *name; /* identifier (optional) */
} t_sig;

typedef struct _patch {
	int length; /* length of patch */
	char *data; /* patch data, an array of bytes of size 'length' */
	char *name; /* identifier (optional) */
} t_patch;

#if ! defined USE_SRP3
/* Used to find the code for hash_init */
char hash_init_sig_data[] = {
	0xff,0xCC, 0xff,0xCC, 0xff,0x33, 0xff,0xC0, 0xff,0xC7, 0xff,0x01, 
	0xff,0x01, 0xff,0x23, 0xff,0x45, 0xff,0x67, 0xff,0xC7, 0xff,0x41, 
	0xff,0x04, 0xff,0x89, 0xff,0xAB, 0xff,0xCD, 0xff,0xEF, 0xff,0xC7, 
	0xff,0x41, 0xff,0x08, 0xff,0xFE, 0xff,0xDC, 0xff,0xBA, 0xff,0x98, 
	0xff,0xC7, 0xff,0x41, 0xff,0x0C, 0xff,0x76, 0xff,0x54, 0xff,0x32, 
	0xff,0x10, 0xff,0xC7, 0xff,0x41, 0xff,0x10, 0xff,0xF0, 0xff,0xE1, 
	0xff,0xD2, 0xff,0xC3, 0xff,0x89, 0xff,0x41, 0xff,0x18, 0xff,0x89, 
	0xff,0x41, 0xff,0x14, 0xff,0xC3, 0xff,0xCC
};

t_sig hash_init_sig = {
	46,
	hash_init_sig_data,
	2,
	"hash_init"
};

/* Used to find the code for hash routine */
char do_hash_sig_data[] = {
	0xff,0x81, 0xff,0xEC, 0xff,0x48, 0xff,0x01, 0xff,0x00, 0xff,0x00, 
	0xff,0x53, 0xff,0x55, 0xff,0x8B, 0xff,0xAC, 0xff,0x24, 0xff,0x54, 
	0xff,0x01, 0xff,0x00, 0xff,0x00, 0xff,0x8B, 0xff,0x45, 0xff,0x14, 
	0xff,0x8B, 0xff,0x55, 0xff,0x1C, 0xff,0x8B, 0xff,0x4D, 0xff,0x18, 
	0xff,0x89, 0xff,0x44, 0xff,0x24, 0xff,0x10, 0xff,0x8B, 0xff,0x45, 
	0xff,0x20, 0xff,0x89, 0xff,0x54, 0xff,0x24, 0xff,0x18, 0xff,0x8B, 
	0xff,0x55, 0xff,0x28, 0xff,0x89, 0xff,0x4C, 0xff,0x24, 0xff,0x14, 
	0xff,0x8B, 0xff,0x4D, 0xff,0x24, 0xff,0x89, 0xff,0x44, 0xff,0x24, 
	0xff,0x1C, 0xff,0x8B, 0xff,0x45, 0xff,0x2C, 0xff,0x89, 0xff,0x54, 
	0xff,0x24, 0xff,0x24, 0xff,0x8B, 0xff,0x55, 0xff,0x34, 0xff,0x89, 
	0xff,0x4C, 0xff,0x24, 0xff,0x20, 0xff,0x8B, 0xff,0x4D, 0xff,0x30, 
	0xff,0x89, 0xff,0x44, 0xff,0x24, 0xff,0x28, 0xff,0x8B, 0xff,0x45, 
	0xff,0x38, 0xff,0x89, 0xff,0x54, 0xff,0x24, 0xff,0x30, 0xff,0x8B, 
	0xff,0x55, 0xff,0x40, 0xff,0x89, 0xff,0x4C, 0xff,0x24, 0xff,0x2C, 
	0xff,0x8B, 0xff,0x4D, 0xff,0x3C, 0xff,0x89, 0xff,0x44, 0xff,0x24, 
	0xff,0x34, 0xff,0x8B, 0xff,0x45, 0xff,0x44, 0xff,0x89, 0xff,0x54, 
	0xff,0x24, 0xff,0x3C, 0xff,0x8B, 0xff,0x55, 0xff,0x4C
};

t_sig do_hash_sig = {
	101,
	do_hash_sig_data,
	0,
	"do_hash"
};


/* Used to find the location of the function that hashes the password for
   the CLIENT_LOGONPROOFREQ packet */
char logon_proof_hash_sig_data[] = {
	0xff,0x83, 0xff,0xEC, 0xff,0x3C, 0xff,0xA1, 0x00,0x00, 0x00,0x00, 
	0x00,0x00, 0x00,0x00, 0xff,0x33, 0xff,0xC4, 0xff,0x89, 0xff,0x44, 
	0xff,0x24, 0xff,0x38, 0xff,0x53, 0xff,0x55, 0xff,0x8B, 0xff,0x6C, 
	0xff,0x24, 0xff,0x4C, 0xff,0x56, 0xff,0x8B, 0xff,0x74, 0xff,0x24, 
	0xff,0x4C, 0xff,0x57, 0xff,0x8B, 0xff,0xF9, 0xff,0x8B, 0xff,0x4C, 
	0xff,0x24, 0xff,0x58, 0xff,0xBA, 0xff,0x20, 0xff,0x00, 0xff,0x00, 
	0xff,0x00, 0xff,0x89, 0xff,0x6C, 0xff,0x24, 0xff,0x20, 0xff,0x89, 
	0xff,0x4C, 0xff,0x24, 0xff,0x1C, 0x00,0x00, 0x00,0x00, 0x00,0x00, 
	0x00,0x00, 0x00,0x00, 0xff,0x8B, 0xff,0xD8, 0xff,0x33, 0xff,0xD2, 
	0xff,0x8B, 0xff,0xCB, 0xff,0x89, 0xff,0x5C, 0xff,0x24, 0xff,0x14, 
	0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xff,0x83, 
	0xff,0xF8, 0xff,0x01, 0xff,0x74, 0xff,0x1E, 0xff,0x8B, 0xff,0xCB, 
	0xff,0xE8, 0xff,0x03, 0xff,0x20, 0xff,0x00, 0xff,0x00
};

t_sig logon_proof_hash_sig = {
	77,
	logon_proof_hash_sig_data,
	0,
	"logon_proof_hash"
};

/* Patches aforementioned function to generate a PvPGN friendly 
   password hash for CLIENT_LOGONPROOFREQ packet */
char logon_proof_hash_patch_data[] = {
	0x55, 0x8B, 0xEC, 0x60, 0x83, 0xEC, 0x54, 0x89, 0xE1, 0xE8, 
	0x00, 0x00, 0x00, 0x00, 0x6A, 0x40, 0x59, 0x8D, 0x7C, 0x24, 
	0x14, 0x89, 0xFA, 0x29, 0xC0, 0xF3, 0xAA, 0x89, 0xD7, 0x8B, 
	0x5D, 0x08, 0x8D, 0x73, 0x20, 0x6A, 0x10, 0x59, 0x51, 0xF3, 
	0xA4, 0x59, 0x4A, 0x42, 0x49, 0x78, 0x0F, 0x8A, 0x02, 0x3C, 
	0x41, 0x72, 0xF6, 0x3C, 0x5A, 0x77, 0xF2, 0x80, 0x0A, 0x20, 
	0xEB, 0xED, 0x89, 0xE1, 0x51, 0x53, 0xE8, 0x00, 0x00, 0x00, 
	0x00, 0x5F, 0x5E, 0x81, 0xC7, 0xA8, 0x00, 0x00, 0x00, 0x6A, 
	0x05, 0x59, 0xF3, 0xA5, 0x83, 0xC4, 0x54, 0x61, 0x5D, 0x29, 
	0xC0, 0x40, 0xC2, 0x0C, 0x00
};

t_patch logon_proof_hash_patch = {
	95,
	logon_proof_hash_patch_data,
	"logon_proof_hash"
};
/*
 8D 8E 2C 04 00 00 8D 95 
 68 FF FF FF E8*92*94*00 
*00 8B CE 85 C0 74 20 6A 
 0C
*/

/* Used to find function where client verifies hash */
char logon_proof_hash_verify_sig_data[] = {
	0xFF,0x8D, 0xFF,0x8E, 0xFF,0x2C, 0xFF,0x04, 0xFF,0x00, 0xFF,0x00, 0xFF,0x8D, 0xFF,0x95, 
	0xff,0x68, 0xff,0xFF, 0xff,0xFF, 0xff,0xFF, 0xff,0xE8, 0x00,0x00, 0x00,0x00, 0x00,0x00, 
	0x00,0x00, 0xff,0x8B, 0xff,0xCE, 0xff,0x85, 0xff,0xC0, 0xff,0x74, 0xff,0x20, 0xff,0x6A, 
	0xff,0x0C
};

t_sig logon_proof_hash_verify_sig = {
	25,
	logon_proof_hash_verify_sig_data,
	21,
	"logon_proof_hash_verify"
};

/* Force client accept */
char logon_proof_hash_verify_patch_data[] = {
	0x75
};

t_patch logon_proof_hash_verify_patch = {
	1,
	logon_proof_hash_verify_patch_data,
	"logon_proof_hash_verify_patch"
};
/*
 55 8B EC 56 57 FF 75 0C 
 8B F2 8B F9 FF 75 08 B9
*1C*F9*A2*6F 56 E8*66*15
*0C*00 85 C0
*/
char lph_verified_sig_data[] = {
	0xFF,0x55, 0xFF,0x8B, 0xFF,0xEC, 0xFF,0x56, 0xFF,0x57, 0xFF,0xFF, 0xFF,0x75, 0xFF,0x0C, 
	0xFF,0x8B, 0xFF,0xF2, 0xFF,0x8B, 0xFF,0xF9, 0xFF,0xFF, 0xFF,0x75, 0xFF,0x08, 0xFF,0xB9,
	0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xFF,0x56, 0xFF,0xE8, 0x00,0x00, 0x00,0x00,
	0x00,0x00, 0x00,0x00, 0xFF,0x85, 0xFF,0xC0
};

t_sig lph_verified_sig = {
	28,
	lph_verified_sig_data,
	22,
	"lph_verified"
};
/*
 8D 45 C0 50 8D 45 A0 50 
 8D 96 2C 04 00 00 8D 8D
 48 FF FF FF E8
*/
char lph_verified_call1_sig_data[] = {
	0xFF,0x8D, 0xFF,0x45, 0xFF,0xC0, 0xFF,0x50, 0xFF,0x8D, 0xFF,0x45, 0xFF,0xA0, 0xFF,0x50,
	0xFF,0x8D, 0xFF,0x96, 0xFF,0x2C, 0xFF,0x04, 0xFF,0x00, 0xFF,0x00, 0xFF,0x8D, 0xFF,0x8D,
	0xFF,0x48, 0xFF,0xFF, 0xFF,0xFF, 0xFF,0xFF, 0xFF,0xE8
};

t_sig lph_verified_call1_sig = {
	21,
	lph_verified_call1_sig_data,
	21,
	"lph_verified1"
};

/*
8D 45 C8 50 8D 45 A8 50 
8D 96 2C 04 00 00 8D 4D 
E8 E8

*/
char lph_verified_call2_sig_data[] = {
	0xFF,0x8D, 0xFF,0x45, 0xFF,0xC8, 0xFF,0x50, 0xFF,0x8D, 0xFF,0x45, 0xFF,0xA8, 0xFF,0x50,
	0xFF,0x8D, 0xFF,0x96, 0xFF,0x2C, 0xFF,0x04, 0xFF,0x00, 0xFF,0x00, 0xFF,0x8D, 0xFF,0x4D,
    0xFF,0xE8, 0xFF,0xE8
};

t_sig lph_verified_call2_sig = {
	18,
	lph_verified_call2_sig_data,
	18,
	"lph_verified2"
};

#endif

/* Used to find the function that uses the AUTHREQ_109 packet to verify
   the server is a battle.net server
   8B 01 3B 02 0F 85 C5 00
   00 00 83 C1 04 83 C2 04
   83 EE 04 73 EB
*/

char auth_req_sig_data[] = { 
	0xFF,0x8B, 0xFF,0x01, 0xFF,0x3B, 0xFF,0x02, 0xFF,0x0F, 0xFF,0x85, 0xFF,0xC5, 0xFF,0x00,
	0xFF,0x00, 0xFF,0x00, 0xFF,0x83, 0xFF,0xC1, 0xFF,0x04, 0xFF,0x83, 0xFF,0xC2, 0xFF,0x04,
	0xFF,0x83, 0xFF,0xEE, 0xFF,0x04, 0xFF,0x73, 0xFF,0xEB
};

t_sig auth_req_sig = {
	21,
	auth_req_sig_data,
	4,
	"auth_req"
};

/* Force verify */
char auth_req_patch_data[] = { 
	0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00
};

t_patch auth_req_patch = {
	6,
	auth_req_patch_data,
	"auth_req"
};

#if ! defined USE_SRP3
/* The createaccount patches patch the client to send a plaintext password 
   that PvPGN can use when creating an account. There are three patches
   due to space limitations preventing one in place patch 
   This one generates jump to the nearest free space, where create_account2 
   patch put call and jump back 
   45 0C 89 75 0C 50 8D 45  
   10 50 E8 A1 FD FF FF 8B
   55 14 8B CE 6A 20 E8 F5  
   09 00 00 8B 4D 10 E8 7D
   */
char create_account1_sig_data[] = {
	0xFF,0x45, 0xFF,0x0C, 0xFF,0x89, 0xFF,0x75, 0xFF,0x0C, 0xFF,0x50, 0xFF,0x8D, 0xFF,0x45,
	0xFF,0x10, 0xFF,0x50, 0xFF,0xE8, 0xFF,0xA1, 0xFF,0xFD, 0xFF,0xFF, 0xFF,0xFF, 0xFF,0x8B,
	0xFF,0x55, 0xFF,0x14, 0xFF,0x8B, 0xFF,0xCE, 0xFF,0x6A, 0xFF,0x20, 0xFF,0xE8, 0xFF,0xF5,
	0xFF,0x09, 0xFF,0x00, 0xFF,0x00, 0xFF,0x8B, 0xFF,0x4D, 0xFF,0x10, 0xFF,0xE8, 0xFF,0x7D
};

t_sig create_account1_sig = {
	32,
	create_account1_sig_data,
	27,
	"create_account1"
};

char create_account1_patch_data[] = {
	0xEB, 0xAA, 0x90
};

t_patch create_account1_patch = {
	3,
	create_account1_patch_data,
	"create_account1"
};
/* 
  Jump to create_account3, not so stable, cos fill in nearest aligment free space
  4D FC B8 01 00 00 00 5F 
  5E 33 CD 5B E8*74*2A*EF
 *FF 8B E5 5D C2 0C 00 CC
  CC CC CC CC CC CC CC CC
  55
*/
char create_account2_sig_data[] = {
	0xFF,0x4D, 0xFF,0xFC, 0xFF,0xB8, 0xFF,0x01, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00, 0xFF,0x5F,
	0xFF,0x5E, 0xFF,0x33, 0xFF,0xCD, 0xFF,0x5B, 0xFF,0xE8, 0x00,0x00, 0x00,0x00, 0x00,0x00,
	0x00,0x00, 0xFF,0x8B, 0xFF,0xE5, 0xFF,0x5D, 0xFF,0xC2, 0xFF,0x0C, 0xFF,0x00, 0xFF,0xCC,
	0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC,
	0xFF,0x55
};

t_sig create_account2_sig = {
	33,
	create_account2_sig_data,
	23,
	"create_account2"
};

char create_account2_patch_data[] = {
	0xE8, 0xF3, 0x00, 0x00, 0x00, 0xEB, 0x50
};

t_patch create_account2_patch = {
	7,
	create_account2_patch_data,
	"create_account2"
};

char create_account3_patch_data[] = {
	0x6A, 0x20, 0x59, 0x56, 0x57, 0x8B, 0xF3, 0x8B, 0x7C, 0x24,
	0x24, 0xF3, 0xA4, 0x5F, 0x5E, 0x8B, 0x4C, 0x24, 0x18, 0xC3,
	0x90, 0x90, 0x90
};

t_patch create_account3_patch = {
	23,
	create_account3_patch_data,
	"create_account3"
};

/* LPH wrapper 
char lph_checked_sig_data[] = {

};

t_sig lph_checked_sig = {
	0,
	lph_checked_sig_data,
	0,
	"lph_verified"
};

char lph_checked_patch_data[] = {
	8B 44 24 08 56 57 8B F9  8B 4C 24 0C 50 51 8B F2
	56 B9 90 13 AD 6F E8 65  9E 03 00 85 C0 74 2C 8B
	96 A8 00 00 00 89 17 8B  8E AC 00 00 00 89 4F 04
	8B 96 B0 00 00 00 89 57  08 8B 8E B4 00 00 00 89
	4F 0C 8B 96 B8 00 00 00  89 57 10 5F 5E C2 08 00
};

t_patch lph_checked_patch = {
	0,
	lph_checked_patch_data,
	"lph_verified"
};*/
#endif
/*
 51 B9*E4*A1*BB*6F E8*5E 
*7C*00*00 B8 01 00 00 00 
 C3

*/
char desync_fix_sig_data[] = {
	0xff,0x51, 0xff,0xb9, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xff,0xe8, 0x00,0x00, 
	0x00,0x00, 0x00,0x00, 0x00,0x00, 0xff,0xb8, 0xff,0x01, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00,
	0xFF,0xC3
};

t_sig desync_sig = {
	17,
	desync_fix_sig_data,
	6,
	"desync"
};

char desync_fix_patch_data[] = {
	0x59, 0xEB, 0x02
};

t_patch desync_patch = {
	3,
	desync_fix_patch_data,
	"desync"
};

/*

 55 8B EC 81 EC 20 02 00
 00 A1*74*A7*B6*BF 33 C5
 89 45 FC 53 56 57 C7 85
 F4 FD FF FF 00 00 00 00
*/

char memory_protect_sig_data[] = {
	0xFF,0x55, 0xFF,0x8B, 0xFF,0xEC, 0xFF,0x81, 0xFF,0xEC, 0xFF,0x20, 0xFF,0x02, 0xFF,0x00,
	0xFF,0x00, 0xFF,0xA1, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xFF,0x33, 0xFF,0xC5, 
	0xFF,0x89, 0xFF,0x45, 0xFF,0xFC, 0xFF,0x53, 0xFF,0x56, 0xFF,0x57, 0xFF,0xC7, 0xFF,0x85, 
	0xFF,0xF4, 0xFF,0xFD, 0xFF,0xFF, 0xFF,0xFF,	0xFF,0x00, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00
};

t_sig memory_protect_sig = {
	32,
	memory_protect_sig_data,
	0,
	"memory_protect"
};

char memory_protect_patch_data[] = {
	0xC3
};

t_patch memory_protect_patch = {
	1,
	memory_protect_patch_data,
	"memory_protect"
};
/*
 B8 FA 00 00 00 C3 CC CC
 CC CC CC CC CC CC CC CC 

*/
char delay_reducer_sig_data[] = {
    0xFF,0xB8, 0xFF,0xFA, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00, 0xFF,0xC3, 0xFF,0xCC, 0xFF,0xCC,
	0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC
};

t_sig delay_reducer_sig = {
	16,
	delay_reducer_sig_data,
	1,
	"delay"
};

char delay_reducer_patch_data[] = {
	0x64
};

t_patch delay_reducer_patch = {
	1,
	delay_reducer_patch_data,
	"delay"
};

char ad_disable_sig_data[] = {
    0xFF,0xA1, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    0xFF,0xC7, 0xFF,0x80, 0xFF,0x70, 0xFF,0x02, 0xFF,0x00,
    0xFF,0x00, 0xFF,0x01, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00,
    0xFF,0xBF, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 
    0xFF,0x8B, 0xFF,0x0D, 0x00,0x00, 0x00,0x00, 0x00,0x00, 
    0x00,0x00, 0xFF,0xE8, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    0x00,0x00, 0xFF,0xA1
};

t_sig ad_disable_sig = {
	32,
	ad_disable_sig_data,
	26,
	"adRemove"
};

char ad_disable_patch_data[] = {
	0x0F, 0x1F, 0x44, 0x00, 0x00
};

t_patch ad_disable_patch = {
	5,
	ad_disable_patch_data,
	"adRemove"
};

/* by Rupan, 8/23/2009 -- reserved for future use
   this will find the call to logon_proof_hash in 1.24
   FIXME: need to mask out call address for generic use
*/
char lph_call_sig_data[] = {
    0xFF,0xE8, 0xFF,0x55, 0xFF,0x9E, 0xFF,0x03, 0xFF,0x00,
	0xFF,0x85, 0xFF,0xC0, 0xFF,0x74, 0xFF,0x2C, 0xFF,0x8B,
	0xFF,0x96, 0xFF,0xA8, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00,
	0xFF,0x89, 0xFF,0x17, 0xFF,0x8B, 0xFF,0x8E, 0xFF,0xAC,
	0xFF,0x00, 0xFF,0x00, 0xFF,0x00, 0xFF,0x89, 0xFF,0x4F,
	0xFF,0x04, 0xFF,0x8B, 0xFF,0x96, 0xFF,0xB0, 0xFF,0x00,
	0xFF,0x00, 0xFF,0x00, 0xFF,0x89, 0xFF,0x57, 0xFF,0x08,
	0xFF,0x8B, 0xFF,0x8E, 0xFF,0xB4, 0xFF,0x00, 0xFF,0x00,
	0xFF,0x00
};


#if ! defined USE_SRP3
/* array of straightforward find sig, then patch patches */
void *game_patches[] = {
	&auth_req_sig, &auth_req_patch,
	&create_account1_sig, &create_account1_patch,
	&logon_proof_hash_verify_sig, &logon_proof_hash_verify_patch,
	&desync_sig, &desync_patch,
	NULL, NULL	/* sentinel */
};
#else
void *game_patches_srp3[] = {
	&auth_req_sig, &auth_req_patch,
	&desync_sig, &desync_patch,   
	NULL, NULL	/* sentinel */
};
  
#endif
void *unimportant_patches[] = {
    &ad_disable_sig, &ad_disable_patch,
    &delay_reducer_sig, &delay_reducer_patch,
	&memory_protect_sig, &memory_protect_patch,
	NULL, NULL /* sentinel */
};